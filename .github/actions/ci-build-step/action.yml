name: ci-build-step
description: CI Build Step
author: Sergey Vlasov
inputs:
  item:
    required: true
    description: The item to build specified in the JSON format
  system:
    required: true
    description: Nix system name
  cachix-name:
    required: false
    description: 'Name of a Cachix cache to push and pull/substitute'
  cachix-extra-pull-names:
    required: false
    description: 'Comma-separated list of names for extra Cachix caches to pull/substitute'
  cachix-auth-token:
    required: false
    description: 'Authentication token for Cachix, needed only for private cache access'
  cachix-signing-key:
    required: false
    description: 'Signing key secret retrieved after creating binary cache on https://cachix.org'
  cachix-skip-push:
    required: false
    description: 'Set to true to disable pushing build results to the cache'
  #cachix-paths-to-push:
  #  required: false
  #  description: 'Whitespace-separated list of paths to push. Leave empty to push every build result.'
  cachix-push-filter:
    required: false
    description: >
      Regular expression to exclude derivations for the cache push, for example
      "(-source$|nixpkgs\.tar\.gz$)".
      Warning: this filter does not guarantee it will not get pushed in case
      the path is part of the closure of something that will get pushed.
  #cachix-args:
  #  required: false
  #  description: 'Extra command-line arguments to pass to cachix. If empty, defaults to -j8'
  cachix-install-command:
    required: false
    description: 'Override the default cachix installation method'
runs:
  using: composite
  steps:
    - name: Install Nix
      uses: sigprof/install-nix-action@6c5ba55bfdc791cfad61ac72e473340c1c3ac992
    - name: Setup Cachix
      uses: cachix/cachix-action@v10
      if: inputs.cachix-name
      with:
        name: ${{ inputs.cachix-name }}
        extraPullNames: ${{ inputs.cachix-extra-pull-names }}
        authToken: ${{ inputs.cachix-auth-token }}
        signingKey: ${{ inputs.cachix-signing-key }}
        skipPush: ${{ inputs.cachix-skip-push }}
        #pathsToPush: ${{ inputs.cachix-paths-to-push }}
        pushFilter: ${{ inputs.cachix-push-filter }}
        #cachixArgs: ${{ inputs.cachix-args }}
        installCommand: ${{ inputs.cachix-install-command }}
    - name: Build
      shell: bash
      env:
        ITEM: ${{ inputs.item }}
        SYSTEM: ${{ inputs.system }}
      run: |
        : Flake build script
        echo "::group::Determining arguments for 'nix build'"
        build_args="$(
          jq -rn --arg system "$SYSTEM" '
            env.ITEM | fromjson |
              (.packages[] | @text ".#packages."+$system+".\(.)")?,
              (.checks[] | @text ".#checks."+$system+".\(.)")?,
              (.hosts[] | @text ".#nixosConfigurations.\(.).config.system.build.toplevel")?
          '
        )"
        printf '  %s\n' $build_args
        echo "::endgroup::"
        echo "::group::Creating derivations for build"
        build_output="$( nix build --dry-run --json $build_args )"
        drv_list="$(
          printf '%s' "$build_output" | jq -r '.[].drvPath'
        )"
        echo "::endgroup::"
        echo "::group::Derivation list:"
        printf '  %s\n' $drv_list
        echo "::endgroup::"
        echo "::group::Building derivations"
        build_result=0
        build_output="$(nix build --print-build-logs --json $drv_list)" || build_result=$?
        echo "::endgroup::"
        if [ "$build_result" = "0" ]; then
          echo "::group::Build results as JSON"
          printf '%s' "$build_output" | jq
          echo "::endgroup::"
          echo "::group::Build output size"
          outputs="$( printf '%s' "$build_output" | jq -r '.[].outputs[]' )"
          nix path-info --size --closure-size --human-readable $outputs ||:
          echo "::endgroup::"
          echo "::group::Build output info as JSON"
          nix path-info --size --closure-size --json $outputs | jq ||:
          echo "::endgroup::"
        fi
        echo "::group::Saving build logs"
        mkdir -p .build/logs
        find /nix/var/log/nix/drvs -type f -printf '%P\n' |
          while read log_src; do
            log_dst="${log_src//\//}"
            printf '%s\n' "$log_dst"
            cp /nix/var/log/nix/drvs/"$log_src" .build/logs/"$log_dst" || touch .build/logs_fail
          done
        echo "::endgroup::"
        if [ -f .build/logs_fail ]; then
          echo "Warning: Some log files could not be copied" 1>&2
        fi
        exit $build_result
    - name: Upload build logs
      if: ${{ always() }}
      uses: actions/upload-artifact@v3.1.0
      with:
        name: build-logs-${{inputs.system}}-${{github.job}}-${{strategy.job-index}}
        path: ".build/logs/*"
        if-no-files-found: ignore
