name: Test
on:
  workflow_dispatch:
    inputs:
      matrixOverride:
        required: false
        description: >
          Matrix override for the manual workflow run (replaces the default matrix completely).

          Simplified syntax: source=owner/repo/branch; nixPath=nixpkgs=channels:nixos-unstable; os=ubuntu-latest,macos-latest

          Alternatively, you can specify a JSON object directly (in this case a
          key may be mapped either to a single value or to an array of possible
          values).

          Unspecified keys will inherit their sets of possible values from the
          default matrix.

jobs:
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.result }}
    steps:
      - id: parse
        name: Parse inputs for manually triggered workflow
        if: ${{ github.event_name == 'workflow_dispatch' }}
        uses: actions/github-script@v4.0.2
        with:
          script: |
            // The `?.` operator does not work
            const payload = context.payload;
            const inputs = payload && payload.inputs;
            const matrixOverrideStr = inputs && inputs.matrixOverride && inputs.matrixOverride.trim();

            if (!matrixOverrideStr) {
              core.info("No matrix override specified.");
              return null;
            };

            let matrixOverride = {};

            if (matrixOverrideStr.startsWith("{") {
              // Parse the parameter as raw JSON.
              try {
                matrixOverride = JSON.parse(matrixOverrideStr);
              } catch (error) {
                core.setFailed(
                  `Invalid workflow input 'matrixOverride': "${matrixOverrideStr}".\n`+
                  `JSON parse failed: ${error.toString()}`
                );
                return null;
              }
            } else {
              // Parse the simplified syntax.
              const params = matrixOverrideStr.split(/\s*;\s*/);
              for (param of params) {
                const nameAndValues = param.match(/^([^=\s]+)\s*=\s*(.*)$/);
                if (!nameAndValues[1] || !nameAndValues[2]) {
                  core.setFailed(
                    `Invalid workflow input 'matrixOverride': "${matrixOverrideStr}".\n`+
                    `Invalid parameter specification "${param}".`
                  );
                  return null;
                }
                const name = nameAndValues[1];
                if (matrixOverride[name]) {
                  core.setFailed(
                    `Invalid workflow input 'matrixOverride': "${matrixOverrideStr}".\n`+
                    `Duplicate key "${name}".`
                  );
                  return null;
                }
                const values = nameAndValues[2].split(/\s*,\s*/);
                matrixOverride[name] = values;
              }
            }

            core.startGroup("Matrix override:");
            core.info(JSON.stringify(matrixOverride, null, 2));
            core.endGroup();

            return matrixOverride;

      - id: matrix
        name: Prepare the matrix
        uses: actions/github-script@v4.0.2
        env:
          MATRIX_OVERRIDE: ${{ steps.parse.outputs.result }}
        with:
          script: |
            const rawDefaultMatrix = {
              source: [
                "qmk/qmk_firmware/master",
                "qmk/qmk_firmware/develop",
              ],
              nixPath: [
                "nixpkgs=channel:nixos-20.09"
              ],
              os: [
                "ubuntu-latest",
                "macos-latest"
              ]
            };

            // Replace "owner/repo/ref" with a JSON object for easier usage:
            // { repo: "owner/repo", ref: "ref" }
            function parseSource(source) {
              if (typeof source === "string") {
                const match = source.match(/^([^\/]*(?:\/[^\/]*)?)(?:\/(.*))?$/);
                return { repo: match[1], ref: match[2] };
              }
              return source
            }

            function parseSourcesInMatrix(matrix) {
              let source = matrix && matrix.source;
              if (source) {
                if (Array.isArray(source)) {
                  source = source.map(parseSource);
                } else {
                  source = parseSource(source);
                }
                return { ...matrix, source: source) };
              }
              return matrix;
            }

            const defaultMatrix = parseSourcesInMatrix(rawDefaultMatrix);

            const matrixOverrideStr = process.env.MATRIX_OVERRIDE;
            const rawMatrixOverride = matrixOverrideStr && JSON.parse(matrixOverrideStr);
            let matrixOverride = null;
            if (rawMatrixOverride) {
              core.startGroup("Matrix override:");
              core.info(JSON.stringify(rawMatrixOverride, null, 2));
              core.endGroup();
              matrixOverride = parseSourcesInMatrix(rawMatrixOverride);
            }

            function expandEntryKeys(entry, keys, startPos) {
              for (let i = startPos; i < keys.length; ++i) {
                const key = keys[i];
                const value = entry[key];
                if (Array.isArray(value)) {
                  return value.flatMap(x => expandEntryKeys({ ...entry, [key]: x }, keys, i + 1));
                }
              }
              return [entry];
            }

            function expandEntry(entry) {
              return expandEntryKeys(entry, Object.keys(entry), 0);
            }

            function addToMatrix(entry) {
              const fullEntry = { ...defaultMatrix, ...entry };
              matrix.include = (matrix.include || []).concat(expandEntry(fullEntry));
            }

            let matrix
            if (matrixOverride) {
              const overrideEntry = { ...defaultMatrix, ...matrixOverride };
              matrix = expandEntry(overrideEntry);
            } else {
              matrix = { ...defaultMatrix };
              addToMatrix({
                source: { repo: "sigprof/qmk_firmware", ref: "nix-shell-updates" },
                extra: "extraValue"
              });
            }

            core.startGroup("Job matrix:");
            core.info(JSON.stringify(matrixOverride, null, 2));
            core.endGroup();

            return matrix;

  dump:
    name: Dump
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - name: Report data
        env:
          DATA: ${{ needs.setup.outputs.matrix }}
        run: |
          printf '%s' "$DATA" | jq

  #un:
  # name: Run
  # needs: setup
  # runs-on: ubuntu-latest
  # strategy:
  #   matrix: ${{ fromJSON(needs.setup.outputs.matrix) }}
  # steps:
  #   - name: Report matrix value
  #     env:
  #       DATA: ${{ toJSON(matrix) }}
  #     run: |
  #       printf '%s' "$DATA" | jq

  #ain:
  # name: Main job
  # needs: init
  # strategy:
  #   matrix: ${{ fromJSON(needs.init.outputs.matrix) }}
  # runs-on: ${{ matrix.os }}
  # steps:
  #   - name: Report matrix values
  #     run: |
  #       echo "Repo: ${{ matrix.source.repo }}"
  #       echo "Ref:  ${{ matrix.source.ref  }}"
  #       echo "nixPath: ${{ matrix.nixPath }}"

