name: CI
on:
  push:
    branches:
      - main
      - master
  pull_request:
  workflow_dispatch:
    inputs:
      flake_only:
        description: 'Run flake tests only'
        default: false
        type: boolean

defaults:
  run:
    # Use `bash` by default.  Note that, according to the documentation, the
    # real command is `bash --noprofile --norc -eo pipefail {0}`, which makes
    # the shell catch any errors in pipelines.
    shell: bash

env:
  CACHIX_NAME: sigprof

  nur_systems: x86_64-linux x86_64-darwin
  nur_channels: nixpkgs-unstable nixos-unstable nixos-22.05 nixos-21.11
  nur_main_channel: nixos-22.05

  flake_only: >-
    ${{
      (!!inputs.flake_only) ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.head.repo.full_name == 'sigprof/test-workflows' &&
        startsWith(github.event.pull_request.head.ref, 'automatic-flake-update/')
      )
    }}

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v2.4.2
      - name: Install Nix
        uses: sigprof/install-nix-action@6c5ba55bfdc791cfad61ac72e473340c1c3ac992
      - name: Setup Cachix
        uses: cachix/cachix-action@v10
        with:
          name: ${{ env.CACHIX_NAME }}
          authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'
          extraPullNames: "pre-commit-hooks"
      - name: Check flake evaluation
        run: nix flake check --no-build
      - name: Prepare matrix for flake build jobs
        id: flake_matrix
        run: |
          # Prepare matrix for flake build jobs
          flake_matrix="$(nix eval --json .\#lib.ciData.matrix)"
          echo "::group::Flake matrix:"
          printf '%s' "$flake_matrix" | jq
          echo "::endgroup::"
          printf '::set-output name=flake_matrix::%s\n' "$flake_matrix"
      - name: Check NUR evaluation
        run: |
          # Check NUR evaluation
          for channel in $nur_channels; do
            echo "::group::NUR evaluation for $channel:"
            nix-env -f . -qa \* --meta --xml \
              --allowed-uris https://static.rust-lang.org \
              --option restrict-eval true \
              --option allow-import-from-derivation true \
              --drv-path --show-trace \
              -I nixpkgs=$(NIX_PATH="nixpkgs=channel:$channel" nix-instantiate --find-file nixpkgs) \
              -I $PWD
            echo "::endgroup::"
          done
      - name: Prepare matrix for NUR build jobs
        id: nur_matrix
        run: |
          # Prepare matrix for NUR build jobs
          nur_matrix=""
          case "$nur_main_channel" in
            (nixos-unstable|nixpkgs-unstable)
              # If the flake follows one of the unstable channels, build NUR
              # packages for both unstable channels after the flake (hoping
              # that the packages would match the flake build results).
              job_for_nixpkgs_unstable="stage2"
              job_for_nixos_unstable="stage2"
              ;;
            (*)
              # If the flake follows a stable channel, build NUR package for
              # unstable channels independently from everything else ...
              job_for_nixpkgs_unstable="other"
              job_for_nixos_unstable="other"
              # ... except when both `nixpkgs-unstable` and `nixos-unstable`
              # are requested
              have_nixpkgs_unstable=
              have_nixos_unstable=
              for channel in $nur_channels; do
                case "$channel" in
                  (nixpkgs-unstable) have_nixpkgs_unstable=t ;;
                  (nixos-unstable) have_nixos_unstable=t ;;
                esac
              done
              # If both unstable branches are requested, `nixpkgs-unstable`
              # should be built in stage1, and `nixos-unstable` should be built
              # in stage3 (this way any errors triggered by the newest code
              # would be triggered early).
              if [ -n "$have_nixpkgs_unstable" ] && [ -n "$have_nixos_unstable" ]; then
                job_for_nixpkgs_unstable="stage1"
                job_for_nixos_unstable="stage3"
              fi
              ;;
          esac
          for system in $nur_systems; do
            for channel in $nur_channels; do
              case "$channel" in
                (nixpkgs-unstable) job="$job_for_nixpkgs_unstable" ;;
                (nixos-unstable) job="$job_for_nixos_unstable" ;;
                (*)
                  if [ "$channel" = "$nur_main_channel" ]; then
                    job="stage2"
                  else
                    job="other"
                  fi
                  ;;
              esac
              nur_matrix_part="$(
                NIX_PATH="nixpkgs=channel:$channel" \
                  nix eval --argstr system "$system" --json -f nur.nix lib.ciData.matrix |
                  jq -c --arg system "$system" --arg channel "$channel" --arg job "$job" '
                    path(.[].nur.nurPackages.item) as $x
                    | getpath($x)
                    | {
                        ($x[0]): {
                          nur: {
                            ($job): {
                              include: [
                                {
                                  channel: $channel,
                                  item: .[]
                                }
                              ]
                            }
                          }
                        }
                      }
                  '
              )"
              echo "::group::NUR matrix part ($system, $channel):"
              printf '%s' "$nur_matrix_part" | jq
              echo "::endgroup::"
              nur_matrix="$nur_matrix$nur_matrix_part"
            done
          done
          printf '::set-output name=nur_matrix::%s\n' "$nur_matrix"
      - name: Make combined matrix for all build jobs
        id: matrix
        env:
          flake_matrix: ${{ steps.flake_matrix.outputs.flake_matrix }}
          nur_matrix: ${{ steps.nur_matrix.outputs.nur_matrix }}
        run: |
          # Make combined matrix for all build jobs
          matrix="$(
            printf '%s' "$flake_matrix$nur_matrix" |
              jq -c -n '
                def mergeRecursive(a; b):
                  a as $a | b as $b
                  | if ($a|type) == "object" and ($b|type) == "object"
                    then reduce ([$a, $b] | add | keys_unsorted[]) as $k (
                      {};
                      .[$k] = mergeRecursive($a[$k]; $b[$k])
                    )
                    elif ($a|type) == "array" and ($b|type) == "array"
                    then $a + $b
                    elif $b == null then $a
                    else $b
                end;
                reduce inputs as $item ({}; mergeRecursive(.; $item))
              '
          )"
          echo "::group::Final matrix:"
          printf '%s' "$matrix" | jq
          echo "::endgroup::"
          printf '::set-output name=matrix::%s\n' "$matrix"
 
  x86_64-linux:
    needs:
      - setup
    uses: ./.github/workflows/ci-per-system.yml
    with:
      system: x86_64-linux
      runs-on: ubuntu-latest
      matrix: ${{ toJSON(fromJSON(needs.setup.outputs.matrix).x86_64-linux) }}
    secrets: inherit

  finish:
    needs:
      - x86_64-linux
    runs-on: ubuntu-latest
    steps:
      - run: echo "Dummy finish"
